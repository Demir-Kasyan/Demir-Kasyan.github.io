<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Tarot by B&W</title>
		<script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@e47f441/dist/aframe-master.min.js"></script>
        <script src="https://ghcdn.rawgit.org/chenzlabs/aframe-ar/8a7ee3b/dist/aframe-ar.min.js"></script>
    <script>
      AFRAME.registerComponent('click', {
          init: function () {
              this.el.addEventListener('click', function (evt) {
                  this.setAttribute("animation",
                                    "property: rotation; dur: 4000; to: 0 0 0; loop: false");
                                                               }
                                      );
                            }
                                                        }
                              );
    </script>
  </head>
  <body>
      
    <header >
        <p class="magicP">
          In order to turn to the spirits of prediction, you must enable the AR function ...
        </p>
    </header>
    <a-scene ar style="display: none;" disp>
      <a-gltf-model id="obj" click = ""
                    visible = "false"
                    rotation = "90 0 0" 
                    id = "card-model" 
                    src = "url(https://cdn.jsdelivr.net/gh/maxhaice/maxhaice.github.io/Card.gltf)">
      </a-gltf-model>
      <a-camera>
        <a-cursor geometry="primitive: ring" color: "#FFC0CB"></a-cursor>
      </a-camera>
    </a-scene>
    <script type="module">
        import {WebXRButton} from '../ar.tarot.scripts/js.module/util/webxr-button.js';
        import {Scene} from '../ar.tarot.scripts/js.module/render/scenes/scene.js';
        import {Renderer, createWebGLContext} from '../ar.tarot.scripts/js.module/render/core/renderer.js';
        import {Node} from '../ar.tarot.scripts/js.module/render/core/node.js';
        import {Gltf2Node} from '../ar.tarot.scripts/js.module/render/nodes/gltf2.js';
        import {DropShadowNode} from '../ar.tarot.scripts/js.module/render/nodes/drop-shadow.js';
        import {vec3} from '../ar.tarot.scripts/js.module/render/math/gl-matrix.js';
        import {Ray} from '../ar.tarot.scripts/js.module/render/math/ray.js';
  
        // XR globals.
        let xrButton = null;
        let xrRefSpace = null;
        let xrViewerSpace = null;
        let xrHitTestSource = null;
  
        // WebGL scene globals.
        let gl = null;
        let renderer = null;
        let scene = new Scene();
        scene.enableStats(false);
  
        let obj = document.querySelector('#obj'); 
  
        let reticle = new Gltf2Node({url: '../res/gltf.tarot.models/reticle/reticle.gltf'});
        reticle.visible = false;
        scene.addNode(reticle);
  
        scene.clear = false;
  
        function initXR() {
          xrButton = new WebXRButton({
            onRequestSession: onRequestSession,
            onEndSession: onEndSession,
            textEnterXRTitle: "START AR",
            textXRNotFoundTitle: "AR NOT FOUND",
            textExitXRTitle: "EXIT  AR",
          });
          document.querySelector('header').appendChild(xrButton.domElement);
  
          if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-ar')
                        .then((supported) => {
              xrButton.enabled = supported;
            });
          }
        }
  
        function onRequestSession() {
          return navigator.xr.requestSession('immersive-ar', {requiredFeatures: ['local', 'hit-test']})
                             .then((session) => {
            xrButton.setSession(session);
            onSessionStarted(session);
          });
        }
  
        function onSessionStarted(session) {
          session.addEventListener('end', onSessionEnded);
          session.addEventListener('select', onSelect);
  
          if (!gl) {
            gl = createWebGLContext({
              xrCompatible: true
            });
  
            renderer = new Renderer(gl);
  
            scene.setRenderer(renderer);
          }
  
          session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
  
          session.requestReferenceSpace('viewer').then((refSpace) => {
            xrViewerSpace = refSpace;
            session.requestHitTestSource({ space: xrViewerSpace }).then((hitTestSource) => {
              xrHitTestSource = hitTestSource;
            });
          });
  
          session.requestReferenceSpace('local').then((refSpace) => {
            xrRefSpace = refSpace;
  
            session.requestAnimationFrame(onXRFrame);
          });
        }
  
        function onEndSession(session) {
          xrHitTestSource.cancel();
          xrHitTestSource = null;
          session.end();
        }
  
        function onSessionEnded(event) {
          xrButton.setSession(null);
        }
  
        function addARObjectAt(matrix) {
          scene.visible = false;
          aScene.style.display = 'inline';
          obj.setAttribute('visible', true);
          obj.setAttribute('position', {x:matrix[0],y:matrix[1],z:matrix[2]});
        }
  
        let rayOrigin = vec3.create();
        let rayDirection = vec3.create();
        function onSelect(event) {
          if (reticle.visible) {
            addARObjectAt(reticle.matrix);
          }
        }
  
        function onXRFrame(t, frame) {
          let session = frame.session;
          let pose = frame.getViewerPose(xrRefSpace);
  
          reticle.visible = false;
  
          if (xrHitTestSource && pose) {
            let hitTestResults = frame.getHitTestResults(xrHitTestSource);
            if (hitTestResults.length > 0) {
              let pose = hitTestResults[0].getPose(xrRefSpace);
              reticle.visible = true;
              reticle.matrix = pose.transform.matrix;
            }
          }
  
          scene.startFrame();
  
          session.requestAnimationFrame(onXRFrame);
  
          scene.drawXRFrame(frame, pose);
  
          scene.endFrame();
        }
  
        initXR();
      </script>
  </body>
</html>
